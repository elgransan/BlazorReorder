@typeparam TItem
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.JSInterop
@inject ReorderService<TItem> rs
@inject NavigationManager nav
@implements IDisposable

@if (Debug)
{
    <p>@log</p>
    <p>@log2</p>
}

@if(rs.selected != null && rs.originItems == Items)
{
    <div class="dragging item" 
         style="width: @(elemWidth)px; left: @(elemPosition.x)px; top: @(elemPosition.y)px; transform: translateX(@(ghostTrans.x)px) translateY(@(ghostTrans.y)px )">
    @ChildContent(rs.selected)
    </div>
}

@if (itemElem != null)
{
    <div class="sortable">
        @foreach (var item in Items.Select((v, i) => (v, i)))
        {
            <div @ref="itemElem[item.i]" class="item @(item.v.Equals(rs.selected) ? "active" : "")"
            @onmousedown="async (e) => await onPress(e, item.v, item.i)">
                @ChildContent(item.v)
            </div>
        }
    </div>
}

@code 
{
    [Parameter, EditorRequired] public RenderFragment<TItem> ChildContent { get; set; } = null!;
    [Parameter, EditorRequired] public List<TItem> Items { get; set; } = null!;
    [Parameter] public bool Copy { get; set; } = false;
    [Parameter] public bool WithShadow { get; set; } = true;
    [Parameter] public bool Debug { get; set; } = false;

    private bool shouldRender = true; // cancel re-rendering
    private DotNetObjectReference<Reorder<TItem>>? dotNetHelper; //js-interop 2-ways
    List<ElementReference>? itemElem;
    point elemPosition = new point(0, 0);
    point ghostTrans = new point(0, 0);
    int elemWidth = 0;
    int newElemIndex = -1;

    string log = "", log2 = "";

    protected override void OnInitialized()
    {
        nav.LocationChanged += HandleLocationChanged;
    }

    public void Dispose()
    {
        nav.LocationChanged -= HandleLocationChanged;
    }

    public void HandleLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        if (dotNetHelper == null) return;
        base.InvokeAsync(async () =>
        {
            await rs.removeEvents(dotNetHelper);
            StateHasChanged();
        });
    }

    protected override void OnParametersSet()
    {
        var count = Items.Count;
        itemElem = new();
        for (int i = 0; i < count; i++) itemElem.Add(default(ElementReference));
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetHelper = DotNetObjectReference.Create(this);
            await rs.initEvents(dotNetHelper);
        }
    }

    public async Task onPress(MouseEventArgs m, TItem item, int index)
    {
        if (itemElem == null) return;
        shouldRender = false; // Because the method triggers re-render, the click propagation is canceled, if you have a link/or any click event inside it's going to stop working
        var ghostElem = itemElem[index];
        elemWidth = await rs.getWidth(ghostElem);
        elemPosition = await rs.getPosition(ghostElem);
        var clickPos = await rs.getPoint(m);
        rs.Set(Items, item, index, itemElem, ghostElem, clickPos);
    }

    [JSInvokable]
    public void onRelease(MouseEventArgs m)
    {
        if (rs.isDragging)
        {
            rs.Reset();
            ghostTrans = new point(0, 0);
            elemPosition = new point(0, 0);
            elemWidth = 0;

            // flip
            if (!WithShadow)
            {
                var item = Items[rs.elemIndex];
                shouldRender = false;
                Items.RemoveAt(rs.elemIndex);
                Items.Insert(newElemIndex, item);
                Log("mouseup");
            }
            shouldRender = true;
            StateHasChanged();
        }
    }

    [JSInvokable]
    public async Task onMove(point pos)
    {
        if (itemElem == null) return;
        //Console.WriteLine(rs.isDragging ? "dragging" : "not dragging");
        if (rs.isDragging)
        {
            ghostTrans = new point(pos.x - rs.elemClickPosition.x, pos.y - rs.elemClickPosition.y);
            Log($"onMove ({ghostTrans.x}, {ghostTrans.y}) {rs.selected}");

            // check if current drag item is over another item and swap places 
            for(var b = 0; b < itemElem.Count; ++b)
            {
                if (rs.originItems == Items && b == rs.elemIndex) continue;
                var subItem = itemElem[b];

                if (await isOnTop(subItem, pos))
                {
                    // reorder
                    newElemIndex = b;
                    var item2 = Items[newElemIndex];
                    Log($"Sobre {item2}");
                    // flip
                    if (WithShadow)
                    {
                        shouldRender = false;
                        rs.originItems.RemoveAt(rs.elemIndex);
                        Items.Insert(newElemIndex, rs.selected);
                        if (rs.originItems != Items)
                        {
                            rs.originItemElem.RemoveAt(rs.elemIndex);
                            itemElem.Insert(newElemIndex, rs.elemRef);
                            rs.originItems = Items;
                            rs.originItemElem = itemElem;
                        }
                        rs.elemIndex = newElemIndex;
                        break;
                    }
                }
            }
            
            shouldRender = true;
            StateHasChanged();
        }

        if (rs.originItems != Items)
        {
            Log("Over another");
        }
    }

    protected override bool ShouldRender()
    {
        return shouldRender;
    }

    // checks if mouse x/y is on top of an item 
    async Task<bool> isOnTop(ElementReference item, point pos)
    {
        var box = await rs.getClientRect(item);
        Log($"\npos x: {pos.x}, y: {pos.y}\n item: left:{box.left}, width:{box.width}\nitem: top:{box.top}, height:{box.height}", true);
        var isx = (pos.x > box.left && pos.x < (box.left + box.width));
        var isy = (pos.y > box.top && pos.y < (box.top + box.height));
        var res = isx && isy;

        return res;
    }

    void Log(string info, bool sublog = false)
    {
        if (Debug)
        {
            if (sublog) log2 = info;
            else log = info;
        }
    }

}
